<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SparkleFlyer3120</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            touch-action: none;
            font-family: 'Comic Sans MS', cursive;
            background: linear-gradient(to bottom, #87CEEB 0%, #E0F7FA 100%);
        }
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
        }
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        #healthBar {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 150px;
            height: 25px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            overflow: hidden;
        }
        #healthFill {
            height: 100%;
            width: 100%;
            background: linear-gradient(to right, #FF5252, #FFEB3B);
            transition: width 0.3s;
        }
        #score {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        #controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            height: 70%;
            pointer-events: none;
        }
        #actionButtons {
            position: absolute;
            bottom: 20px;
            right: 20px;
            pointer-events: auto;
        }
        #jumpBtn {
            width: 70px;
            height: 70px;
            background: radial-gradient(circle, rgba(255,215,0,0.5) 0%, rgba(255,215,0,0.3) 70%);
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 50%;
            color: white;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            margin-bottom: 10px;
        }
        #attackBtn {
            width: 70px;
            height: 70px;
            background: radial-gradient(circle, rgba(255,105,180,0.5) 0%, rgba(255,105,180,0.3) 70%);
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 50%;
            color: white;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        #questBtn {
            position: absolute;
            top: 20px;
            right: 80px;
            width: 40px;
            height: 40px;
            background: rgba(255,255,255,0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            cursor: pointer;
        }
        #questMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-height: 70%;
            background: rgba(0,0,0,0.7);
            border-radius: 15px;
            padding: 20px;
            color: white;
            display: none;
            pointer-events: auto;
            overflow-y: auto;
            z-index: 100;
        }
        .quest-tabs {
            display: flex;
            margin-bottom: 15px;
        }
        .quest-tab {
            padding: 8px 15px;
            background: rgba(255,255,255,0.2);
            margin-right: 5px;
            border-radius: 5px;
            cursor: pointer;
        }
        .quest-tab.active {
            background: rgba(255,215,0,0.5);
        }
        .quest-content {
            display: none;
        }
        .quest-content.active {
            display: block;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            pointer-events: auto;
            z-index: 100;
        }
        #restartBtn {
            background: #FF5252;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            margin-top: 20px;
            cursor: pointer;
        }
        .emotion-bubble {
            position: absolute;
            background: white;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transform: translateY(-50px);
            opacity: 0;
            transition: opacity 0.3s, transform 0.5s;
            pointer-events: none;
        }
        .projectile {
            position: absolute;
            width: 10px;
            height: 10px;
            background: radial-gradient(circle, #FFD700, #FF69B4);
            border-radius: 50%;
            pointer-events: none;
            z-index: 5;
        }
        .sparkle-effect {
            position: absolute;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, rgba(255,215,0,0.8), rgba(255,105,180,0.5));
            border-radius: 50%;
            pointer-events: none;
            z-index: 5;
            transform: scale(0);
            animation: sparkle 0.5s ease-out;
        }
        @keyframes sparkle {
            0% { transform: scale(0); opacity: 1; }
            50% { transform: scale(1.5); opacity: 0.7; }
            100% { transform: scale(0); opacity: 0; }
        }
        .building-highlight {
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(255,255,255,0.3);
            pointer-events: none;
            z-index: 2;
            animation: highlight 1s;
        }
        @keyframes highlight {
            0% { opacity: 0.7; }
            100% { opacity: 0; }
        }
        .touch-area {
            position: absolute;
            bottom: 0;
            height: 70%;
            background: rgba(255,255,255,0.0);
            pointer-events: auto;
        }
        #left-touch {
            left: 0;
            width: 50%;
        }
        #right-touch {
            right: 0;
            width: 50%;
        }
        .dialogue-box {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 10px;
            max-width: 80%;
            text-align: center;
            display: none;
            pointer-events: auto;
            z-index: 20;
        }
        #interiorView {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #8B4513;
            display: none;
            z-index: 15;
            pointer-events: auto;
        }
        #miniGameContainer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }
        #memoryGame {
            display: grid;
            grid-template-columns: repeat(4, 60px);
            grid-gap: 10px;
            margin: 20px auto;
        }
        .memory-card {
            width: 60px;
            height: 60px;
            background: #FF69B4;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .memory-card.flipped {
            background: white;
            transform: rotateY(180deg);
        }
        #miniGameMessage {
            margin-top: 15px;
            font-size: 18px;
            color: white;
        }
        #exitInterior {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 5px 10px;
            background: #FF5252;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .quest-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        .quest-checkbox {
            margin-right: 10px;
        }
        .completed {
            color: #AAAAAA;
            text-decoration: line-through;
        }
        #platformReward {
            position: absolute;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #FFD700, #FFAA00);
            border-radius: 50%;
            display: none;
            pointer-events: none;
            z-index: 5;
        }
        #shapeGame {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
        }
        .shape-row {
            display: flex;
            margin-bottom: 10px;
        }
        .shape-option {
            width: 60px;
            height: 60px;
            margin: 0 10px;
            background: #87CEEB;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            cursor: pointer;
        }
        .shape-option:hover {
            background: #FF69B4;
        }
        #shapeTarget {
            width: 100px;
            height: 100px;
            background: #FFD700;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 50px;
            margin-bottom: 20px;
        }
        #shapeMessage {
            margin-top: 15px;
            font-size: 18px;
            color: white;
        }
        #victoryScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
            pointer-events: auto;
            z-index: 200;
            width: 80%;
            max-width: 500px;
        }
        #victoryScreen h2 {
            color: gold;
            font-size: 36px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(255,215,0,0.8);
        }
        #nextLevelBtn {
            background: linear-gradient(to right, #FFD700, #FF69B4);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            margin-top: 30px;
            font-size: 20px;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(255,215,0,0.5);
        }
        .sparkle-text {
            background: linear-gradient(45deg, #FFD700, #FF69B4, #87CEEB);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 5px rgba(255,255,255,0.5);
        }
        .castle-door {
            position: absolute;
            width: 3px;
            height: 6px;
            background: rgba(139, 69, 19, 0.5);
            z-index: 5;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="ui">
        <div id="healthBar">
            <div id="healthFill"></div>
        </div>
        <div id="score">0</div>
        <div id="questBtn">üìã</div>
        <div class="touch-area" id="left-touch"></div>
        <div class="touch-area" id="right-touch"></div>

        <div id="controls">
            <div id="actionButtons">
                <div id="jumpBtn">JUMP</div>
                <div id="attackBtn">SPARKLE</div>
            </div>
        </div>

        <div id="questMenu">
            <div class="quest-tabs">
                <div class="quest-tab active" data-tab="objectives">Objectives</div>
                <div class="quest-tab" data-tab="inventory">Inventory</div>
                <div class="quest-tab" data-tab="score">Score</div>
            </div>

            <div class="quest-content active" id="objectivesTab">
                <h3>Your Quest:</h3>
                <ul id="objectivesList">
                </ul>
            </div>

            <div class="quest-content" id="inventoryTab">
                <h3>Inventory:</h3>
                <ul id="inventoryList">
                </ul>
            </div>

            <div class="quest-content" id="scoreTab">
                <h3>Your Progress:</h3>
                <div id="scoreDetails">
                    <p>Total Score: <span id="totalScore">0</span></p>
                    <p>Level: <span id="gameLevel">1</span></p>
                    <p>Completion: <span id="completion">0%</span></p>
                </div>
            </div>
        </div>

        <div id="gameOver">
            <h2>Game Over!</h2>
            <p>Don't worry, every adventure has its challenges!</p>
            <button id="restartBtn">Try Again</button>
        </div>

        <div id="victoryScreen">
            <h2 class="sparkle-text">Congratulations!</h2>
            <p>You've completed all the quests in Sparkle Quest Village!</p>
            <p>Your final score: <span id="finalScore" class="sparkle-text">0</span></p>
            <p>You are now ready to enter the Sparkle Academy!</p>
            <button id="nextLevelBtn">Enter Sparkle Academy</button>
        </div>

        <div class="dialogue-box" id="dialogueBox"></div>
        
        <div id="interiorView">
            <button id="exitInterior">Exit</button>
            <div id="miniGameContainer">
                <h3>Memory Match Game</h3>
                <p>Find all matching pairs to win a reward!</p>
                <div id="memoryGame"></div>
                <div id="miniGameMessage"></div>
                
                <div id="shapeGame" style="display: none;">
                    <h3>Shape Matching Game</h3>
                    <p>Match the shape below!</p>
                    <div id="shapeTarget">?</div>
                    <div class="shape-row">
                        <div class="shape-option" data-shape="üî∫">üî∫</div>
                        <div class="shape-option" data-shape="üîµ">üîµ</div>
                        <div class="shape-option" data-shape="‚≠ê">‚≠ê</div>
                    </div>
                    <div class="shape-row">
                        <div class="shape-option" data-shape="‚ù§Ô∏è">‚ù§Ô∏è</div>
                        <div class="shape-option" data-shape="üî∂">üî∂</div>
                        <div class="shape-option" data-shape="üî∑">üî∑</div>
                    </div>
                    <div id="shapeMessage"></div>
                </div>
            </div>
        </div>

        <div id="platformReward"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game Initialization
        const canvas = document.getElementById('gameCanvas');
        const renderer = new THREE.WebGLRenderer({ 
            canvas, 
            antialias: true,
            powerPreference: "high-performance"
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        const scene = new THREE.Scene();
        scene.background = new THREE.Color('#87CEEB');
        scene.fog = new THREE.FogExp2('#87CEEB', 0.002);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10);

        // Texture loader
        const textureLoader = new THREE.TextureLoader();
        
        // Load textures with error handling
        function loadTexture(url) {
            const texture = textureLoader.load(url, undefined, undefined, function(err) {
                console.error('Error loading texture:', url, err);
            });
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        const groundTexture = loadTexture('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');
        groundTexture.repeat.set(10, 10);
        
        const woodTexture = loadTexture('https://threejs.org/examples/textures/wood/wood_512x512.jpg');
        woodTexture.repeat.set(4, 4);
        
        const brickTexture = loadTexture('https://threejs.org/examples/textures/brick_diffuse.jpg');
        brickTexture.repeat.set(2, 2);
        
        const stoneTexture = loadTexture('https://threejs.org/examples/textures/stone/stone.jpg');
        stoneTexture.repeat.set(2, 2);

        // Path textures
        const cobblestoneTexture = loadTexture('https://threejs.org/examples/textures/brick_diffuse.jpg');
        cobblestoneTexture.repeat.set(2, 2);
        
        const dirtTexture = loadTexture('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');
        dirtTexture.repeat.set(1, 1);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        scene.add(directionalLight);

        // Ground with texture
        const groundGeometry = new THREE.PlaneGeometry(200, 200);
        const groundMaterial = new THREE.MeshStandardMaterial({
            map: groundTexture,
            roughness: 0.8,
            metalness: 0.2
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
        
        // Collision detection
        const collidableObjects = [];
        const buildings = [];
        const houseInteriors = [];
        const platforms = [];
        const paths = [];
        
        // Timer for debouncing interior entry
        let lastInteriorInteractionTime = 0;
        const interiorCooldown = 1000; // 1 second cooldown

        // Trees
        function createTree(x, z) {
            const treeGroup = new THREE.Group();

            // Trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.4, 2, 12);
            const trunkMaterial = new THREE.MeshStandardMaterial({ 
                map: woodTexture,
                roughness: 0.6
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 1;
            trunk.castShadow = true;
            treeGroup.add(trunk);

            // Leaves
            const leavesGeometry = new THREE.SphereGeometry(1.5, 16, 16);
            const leavesMaterial = new THREE.MeshStandardMaterial({ 
                color: '#228B22',
                roughness: 0.5,
                transparent: true,
                opacity: 0.9
            });
            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves.position.y = 3;
            leaves.castShadow = true;
            treeGroup.add(leaves);

            treeGroup.position.set(x, 0, z);
            scene.add(treeGroup);
            
            // Collision box
            const trunkCollider = new THREE.Mesh(
                new THREE.CylinderGeometry(0.4, 0.4, 2, 8),
                new THREE.MeshBasicMaterial({ visible: false })
            );
            trunkCollider.position.copy(trunk.position);
            trunkCollider.position.y = 1;
            scene.add(trunkCollider);
            collidableObjects.push(trunkCollider);

            return treeGroup;
        }

        // Create random trees
        for (let i = 0; i < 20; i++) {
            createTree(
                (Math.random() - 0.5) * 180,
                (Math.random() - 0.5) * 180
            );
        }

        // Sparkle Academy Castle
        const academyGroup = new THREE.Group();

        // Main castle structure
        const castleBaseGeometry = new THREE.BoxGeometry(15, 10, 15);
        const castleBaseMaterial = new THREE.MeshStandardMaterial({
            map: brickTexture,
            roughness: 0.7,
            metalness: 0.1
        });
        const castleBase = new THREE.Mesh(castleBaseGeometry, castleBaseMaterial);
        castleBase.position.y = 5;
        castleBase.castShadow = true;
        castleBase.receiveShadow = true;
        academyGroup.add(castleBase);

        // Castle towers
        const towerGeometry = new THREE.CylinderGeometry(2, 2, 15, 8);
        const towerMaterial = new THREE.MeshStandardMaterial({
            map: brickTexture,
            roughness: 0.7
        });
        
        const towerPositions = [
            [6, 0, 6], [6, 0, -6], [-6, 0, 6], [-6, 0, -6]
        ];
        
        for (const [x, z] of towerPositions) {
            const tower = new THREE.Mesh(towerGeometry, towerMaterial);
            tower.position.set(x, 7.5, z);
            tower.castShadow = true;
            academyGroup.add(tower);
            
            // Tower roofs
            const roofGeometry = new THREE.ConeGeometry(2.5, 4, 8);
            const roofMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B0000,
                roughness: 0.5
            });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.set(x, 15, z);
            academyGroup.add(roof);
        }

        // Main castle roof
        const mainRoofGeometry = new THREE.ConeGeometry(10, 6, 4);
        const mainRoofMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x8B0000,
            roughness: 0.5
        });
        const mainRoof = new THREE.Mesh(mainRoofGeometry, mainRoofMaterial);
        mainRoof.position.y = 15;
        mainRoof.rotation.y = Math.PI / 4;
        academyGroup.add(mainRoof);

        // Castle entrance
        const entranceGeometry = new THREE.BoxGeometry(5, 8, 3);
        const entranceMaterial = new THREE.MeshStandardMaterial({
            map: brickTexture,
            roughness: 0.7
        });
        const entrance = new THREE.Mesh(entranceGeometry, entranceMaterial);
        entrance.position.set(0, 4, 7.5);
        academyGroup.add(entrance);

        // Door
        const doorGeometry = new THREE.BoxGeometry(3, 6, 0.2);
        const doorMaterial = new THREE.MeshStandardMaterial({ 
            color: '#8B4513',
            roughness: 0.5
        });
        const door = new THREE.Mesh(doorGeometry, doorMaterial);
        door.position.set(0, 3, 8.6);
        academyGroup.add(door);

        // Windows
        const windowGeometry = new THREE.PlaneGeometry(2, 2);
        const windowMaterial = new THREE.MeshStandardMaterial({
            color: '#87CEEB',
            emissive: '#87CEEB',
            emissiveIntensity: 0.3,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.8
        });
        
        // Add windows to towers
        for (const [x, z] of towerPositions) {
            const window = new THREE.Mesh(windowGeometry, windowMaterial);
            window.position.set(x, 10, z - 2.1);
            window.rotation.y = Math.PI;
            academyGroup.add(window);
        }
        
        // Add windows to main castle
        const mainWindowPositions = [
            [5, 8, 0], [-5, 8, 0], [0, 8, 5], [0, 8, -5]
        ];
        
        for (const [x, y, z] of mainWindowPositions) {
            const window = new THREE.Mesh(windowGeometry, windowMaterial);
            window.position.set(x, y, z);
            if (x !== 0) {
                window.rotation.y = Math.PI / 2 * Math.sign(x);
            } else {
                window.rotation.y = z > 0 ? 0 : Math.PI;
            }
            academyGroup.add(window);
        }

        // Sparkle effect at the top
        const sparkleGeometry = new THREE.SphereGeometry(1, 16, 16);
        const sparkleMaterial = new THREE.MeshStandardMaterial({
            color: 0xFFD700,
            emissive: 0xFFD700,
            emissiveIntensity: 0.7,
            transparent: true,
            opacity: 0.9
        });
        const sparkle = new THREE.Mesh(sparkleGeometry, sparkleMaterial);
        sparkle.position.set(0, 22, 0);
        academyGroup.add(sparkle);

        academyGroup.position.set(0, 0, -70);
        scene.add(academyGroup);
        
        // Add collision box for academy
        const academyCollider = new THREE.Mesh(
            new THREE.BoxGeometry(15, 10, 15),
            new THREE.MeshBasicMaterial({ visible: false })
        );
        academyCollider.position.copy(academyGroup.position);
        academyCollider.position.y = 5;
        scene.add(academyCollider);
        collidableObjects.push(academyCollider);
        buildings.push(academyGroup);

        // Path creation function
        function createPath(startX, startZ, endX, endZ, width = 3, isMainPath = false) {
            const pathGroup = new THREE.Group();
            
            // Calculate path length and angle
            const dx = endX - startX;
            const dz = endZ - startZ;
            const length = Math.sqrt(dx * dx + dz * dz);
            const angle = Math.atan2(dz, dx);
            
            // Create path mesh
            const pathGeometry = new THREE.PlaneGeometry(length, width, 1, 1);
            const pathMaterial = new THREE.MeshStandardMaterial({
                map: isMainPath ? cobblestoneTexture : dirtTexture,
                roughness: 0.8,
                metalness: 0.1
            });
            const path = new THREE.Mesh(pathGeometry, pathMaterial);
            path.rotation.x = -Math.PI / 2;
            path.position.set((startX + endX) / 2, 0.01, (startZ + endZ) / 2);
            path.rotation.y = -angle;
            path.receiveShadow = true;
            pathGroup.add(path);
            
            // Add edges for main paths
            if (isMainPath) {
                const edgeGeometry = new THREE.PlaneGeometry(length, 0.3);
                const edgeMaterial = new THREE.MeshStandardMaterial({
                    color: 0x654321,
                    roughness: 0.7
                });
                
                const topEdge = new THREE.Mesh(edgeGeometry, edgeMaterial);
                topEdge.position.set(0, 0.05, width/2 - 0.15);
                topEdge.rotation.x = -Math.PI / 2;
                topEdge.rotation.y = -angle;
                pathGroup.add(topEdge);
                
                const bottomEdge = new THREE.Mesh(edgeGeometry, edgeMaterial);
                bottomEdge.position.set(0, 0.05, -width/2 + 0.15);
                bottomEdge.rotation.x = -Math.PI / 2;
                bottomEdge.rotation.y = -angle;
                pathGroup.add(bottomEdge);
            }
            
            scene.add(pathGroup);
            paths.push(pathGroup);
            
            return pathGroup;
        }

        // Village path layout
        function createVillagePaths() {
            // Main paths (cobblestone)
            createPath(-50, 0, 50, 0, 5, true);
            createPath(0, -80, 0, 70, 5, true);
            
            // Connecting paths (dirt)
            createPath(-20, 0, -20, 40, 3);
            createPath(20, 0, 20, 40, 3);
            createPath(-35, 25, 35, 25, 3);
            
            // Path to academy (cobblestone)
            createPath(0, -10, 0, -65, 6, true);
            
            // Small paths (dirt)
            createPath(-20, 40, -40, 25, 2);
            createPath(20, 40, 40, 25, 2);
            createPath(-15, 25, -15, 60, 2);
            createPath(15, 25, 15, 60, 2);
        }

        // Houses with improved collision
        function createHouse(x, z) {
            const houseGroup = new THREE.Group();

            // Base with brick texture
            const baseGeometry = new THREE.BoxGeometry(6, 4, 6);
            const baseMaterial = new THREE.MeshStandardMaterial({ 
                map: brickTexture,
                roughness: 0.6,
                metalness: 0.1
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 2;
            base.castShadow = true;
            base.receiveShadow = true;
            houseGroup.add(base);

            // Roof
            const roofGeometry = new THREE.ConeGeometry(5, 3, 4);
            const roofMaterial = new THREE.MeshStandardMaterial({ 
                map: woodTexture,
                roughness: 0.5
            });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = 5.5;
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            houseGroup.add(roof);

            // Door
            const doorGeometry = new THREE.BoxGeometry(1, 2, 0.2);
            const doorMaterial = new THREE.MeshStandardMaterial({ 
                color: '#8B4513',
                roughness: 0.5
            });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(0, 1, 3.01);
            houseGroup.add(door);

            // Windows
            const windowGeometry = new THREE.PlaneGeometry(1, 1);
            const windowMaterial = new THREE.MeshStandardMaterial({
                color: '#87CEEB',
                emissive: '#87CEEB',
                emissiveIntensity: 0.2,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.8
            });
            const window1 = new THREE.Mesh(windowGeometry, windowMaterial);
            window1.position.set(-2, 2.5, 3.01);
            houseGroup.add(window1);

            const window2 = new THREE.Mesh(windowGeometry, windowMaterial);
            window2.position.set(2, 2.5, 3.01);
            houseGroup.add(window2);

            houseGroup.position.set(x, 0, z);
            scene.add(houseGroup);
            
            // Collision box (slightly smaller than visual)
            const houseCollider = new THREE.Mesh(
                new THREE.BoxGeometry(5.8, 3.8, 5.8),
                new THREE.MeshBasicMaterial({ visible: false })
            );
            houseCollider.position.copy(houseGroup.position);
            houseCollider.position.y = 2;
            scene.add(houseCollider);
            collidableObjects.push(houseCollider);
            buildings.push(houseGroup);

            // Create interior
            const interiorGroup = new THREE.Group();
            interiorGroup.position.set(x, 0, z);
            interiorGroup.visible = false;
            scene.add(interiorGroup);
            
            // Floor
            const floorGeometry = new THREE.PlaneGeometry(5, 5);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                map: woodTexture,
                roughness: 0.7
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            interiorGroup.add(floor);
            
            // Walls
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: '#F5DEB3',
                roughness: 0.6
            });
            
            const backWall = new THREE.Mesh(
                new THREE.PlaneGeometry(5, 3),
                wallMaterial
            );
            backWall.position.set(0, 1.5, -2.5);
            backWall.rotation.y = Math.PI;
            interiorGroup.add(backWall);
            
            const leftWall = new THREE.Mesh(
                new THREE.PlaneGeometry(5, 3),
                wallMaterial
            );
            leftWall.position.set(-2.5, 1.5, 0);
            leftWall.rotation.y = Math.PI / 2;
            interiorGroup.add(leftWall);
            
            const rightWall = new THREE.Mesh(
                new THREE.PlaneGeometry(5, 3),
                wallMaterial
            );
            rightWall.position.set(2.5, 1.5, 0);
            rightWall.rotation.y = -Math.PI / 2;
            interiorGroup.add(rightWall);
            
            // Ceiling
            const ceiling = new THREE.Mesh(
                new THREE.PlaneGeometry(5, 5),
                new THREE.MeshStandardMaterial({ color: '#D2B48C' })
            );
            ceiling.position.set(0, 3, 0);
            ceiling.rotation.x = Math.PI / 2;
            interiorGroup.add(ceiling);
            
            // Furniture - Table
            const tableGeometry = new THREE.BoxGeometry(1.5, 0.5, 1.5);
            const tableMaterial = new THREE.MeshStandardMaterial({ 
                map: woodTexture,
                roughness: 0.5
            });
            const table = new THREE.Mesh(tableGeometry, tableMaterial);
            table.position.set(0, 0.25, 0);
            interiorGroup.add(table);
            
            // Furniture - Chair
            const chairSeat = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 0.1, 0.8),
                tableMaterial
            );
            chairSeat.position.set(1, 0.4, 0);
            interiorGroup.add(chairSeat);
            
            const chairBack = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 0.8, 0.1),
                tableMaterial
            );
            chairBack.position.set(1, 0.8, 0.35);
            interiorGroup.add(chairBack);
            
            houseInteriors.push({
                exterior: houseGroup,
                interior: interiorGroup,
                position: new THREE.Vector3(x, 0, z),
                doorPosition: new THREE.Vector3(x, 1, z + 3.01)
            });

            return houseGroup;
        }

        // Improved platform creation
        function createPlatform(x, z, height, hasReward = true) {
            const platformGroup = new THREE.Group();
            
            // Platform base (wider)
            const platformGeometry = new THREE.BoxGeometry(5, 0.8, 5);
            const platformMaterial = new THREE.MeshStandardMaterial({
                map: stoneTexture,
                roughness: 0.6
            });
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            platform.position.y = height;
            platform.castShadow = true;
            platform.receiveShadow = true;
            platformGroup.add(platform);
            
            // Support pillars (thicker)
            const pillarGeometry = new THREE.CylinderGeometry(0.8, 0.8, height, 8);
            const pillarMaterial = new THREE.MeshStandardMaterial({
                map: stoneTexture,
                roughness: 0.7
            });
            
            // Add four pillars at corners
            const pillarPositions = [
                [2, 2], [2, -2], [-2, 2], [-2, -2]
            ];
            
            for (const [px, pz] of pillarPositions) {
                const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
                pillar.position.set(px, height / 2, pz);
                platformGroup.add(pillar);
            }
            
            // Sparkle effect
            if (hasReward) {
                const sparkleGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                const sparkleMaterial = new THREE.MeshStandardMaterial({
                    color: 0xFFD700,
                    emissive: 0xFFD700,
                    emissiveIntensity: 0.5,
                    transparent: true,
                    opacity: 0.8
                });
                const sparkle = new THREE.Mesh(sparkleGeometry, sparkleMaterial);
                sparkle.position.set(0, height + 0.5, 0);
                platformGroup.add(sparkle);
            }
            
            platformGroup.position.set(x, 0, z);
            scene.add(platformGroup);
            
            // Add collision box for platform
            const platformCollider = new THREE.Mesh(
                new THREE.BoxGeometry(5, 0.8, 5),
                new THREE.MeshBasicMaterial({ visible: false })
            );
            platformCollider.position.copy(platformGroup.position);
            platformCollider.position.y = height;
            scene.add(platformCollider);
            
            collidableObjects.push(platformCollider);
            platforms.push({
                mesh: platformGroup,
                platform: platformCollider,
                height: height,
                hasReward: hasReward,
                rewardCollected: false
            });
            
            return platformGroup;
        }

        // Player Character
        const playerGroup = new THREE.Group();
        const playerCollider = new THREE.Box3();

        // Body
        const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 16);
        const bodyMaterial = new THREE.MeshStandardMaterial({
            color: '#FFDAB9',
            roughness: 0.4,
            metalness: 0.1
        });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.position.y = 0.75;
        body.castShadow = true;
        playerGroup.add(body);

        // Head
        const headGeometry = new THREE.SphereGeometry(0.5, 24, 24);
        const headMaterial = new THREE.MeshStandardMaterial({
            color: '#FFDAB9',
            roughness: 0.3
        });
        const head = new THREE.Mesh(headGeometry, headMaterial);
        head.position.y = 1.8;
        head.castShadow = true;
        playerGroup.add(head);

        // Face
        const eyeGeometry = new THREE.SphereGeometry(0.08, 12, 12);
        const eyeMaterial = new THREE.MeshStandardMaterial({ color: '#000000' });
        
        const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        leftEye.position.set(-0.15, 1.85, 0.45);
        playerGroup.add(leftEye);

        const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        rightEye.position.set(0.15, 1.85, 0.45);
        playerGroup.add(rightEye);

        // Mouth
        const mouthGeometry = new THREE.TorusGeometry(0.1, 0.02, 8, 12, Math.PI);
        const mouthMaterial = new THREE.MeshStandardMaterial({ color: '#FF6B6B' });
        const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
        mouth.position.set(0, 1.75, 0.45);
        mouth.rotation.x = Math.PI;
        playerGroup.add(mouth);

        // Hair
        const hairGeometry = new THREE.PlaneGeometry(1.2, 0.5);
        const hairMaterial = new THREE.MeshStandardMaterial({
            color: '#8B4513',
            side: THREE.DoubleSide
        });
        const hair = new THREE.Mesh(hairGeometry, hairMaterial);
        hair.position.set(0, 2.0, -0.3);
        hair.rotation.x = Math.PI / 4;
        playerGroup.add(hair);

        // Arms
        const armGeometry = new THREE.CylinderGeometry(0.12, 0.12, 1, 12);
        const armMaterial = new THREE.MeshStandardMaterial({ 
            color: '#FFDAB9',
            roughness: 0.4
        });

        const leftArm = new THREE.Mesh(armGeometry, armMaterial);
        leftArm.position.set(-0.7, 1.1, 0);
        leftArm.rotation.z = Math.PI / 6;
        playerGroup.add(leftArm);

        const rightArm = new THREE.Mesh(armGeometry, armMaterial);
        rightArm.position.set(0.7, 1.1, 0);
        rightArm.rotation.z = -Math.PI / 6;
        playerGroup.add(rightArm);

        // Legs
        const legGeometry = new THREE.CylinderGeometry(0.15, 0.15, 1, 12);
        const legMaterial = new THREE.MeshStandardMaterial({ 
            color: '#4169E1',
            roughness: 0.5
        });

        const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
        leftLeg.position.set(-0.3, 0.2, 0);
        playerGroup.add(leftLeg);

        const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
        rightLeg.position.set(0.3, 0.2, 0);
        playerGroup.add(rightLeg);

        // Cape
        const capeGeometry = new THREE.PlaneGeometry(1.2, 1.5, 4, 4);
        const capeVertices = capeGeometry.attributes.position;
        for (let i = 0; i < capeVertices.count; i++) {
            const x = capeVertices.getX(i);
            const z = capeVertices.getZ(i);
            capeVertices.setZ(i, z + Math.sin(x * 2) * 0.2);
        }
        capeGeometry.computeVertexNormals();
        
        const capeMaterial = new THREE.MeshStandardMaterial({
            color: '#FF4500',
            side: THREE.DoubleSide,
            roughness: 0.7
        });
        const cape = new THREE.Mesh(capeGeometry, capeMaterial);
        cape.position.set(0, 1.2, -0.6);
        cape.rotation.y = Math.PI;
        playerGroup.add(cape);

        playerGroup.position.y = 1;
        scene.add(playerGroup);

        // Gems
        const gems = [];
        const gemGeometry = new THREE.OctahedronGeometry(0.5, 2);
        const gemMaterial = new THREE.MeshStandardMaterial({
            color: '#FFD700',
            emissive: '#FFAA00',
            emissiveIntensity: 0.5,
            roughness: 0.1,
            metalness: 0.9,
            transparent: true,
            opacity: 0.9
        });

        const numGems = 20;
        for (let i = 0; i < numGems; i++) {
            const gem = new THREE.Mesh(gemGeometry, gemMaterial);
            gem.position.set(
                (Math.random() - 0.5) * 180,
                1,
                (Math.random() - 0.5) * 180
            );
            gem.castShadow = true;
            scene.add(gem);
            gems.push({
                mesh: gem,
                collected: false,
                rotationSpeed: Math.random() * 0.02 + 0.01
            });
        }

        // Sparkle Globes
        const sparkleGlobes = [];
        const globeGeometry = new THREE.IcosahedronGeometry(0.7, 2);
        const globeMaterial = new THREE.MeshStandardMaterial({
            color: '#00FFFF',
            emissive: '#00FFFF',
            emissiveIntensity: 0.7,
            roughness: 0.1,
            metalness: 0.9,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });

        for (let i = 0; i < 5; i++) {
            const globe = new THREE.Mesh(globeGeometry, globeMaterial);
            globe.position.set(
                (Math.random() - 0.5) * 100,
                2,
                (Math.random() - 0.5) * 100
            );
            globe.castShadow = true;
            scene.add(globe);
            sparkleGlobes.push({
                mesh: globe,
                collected: false,
                rotationSpeed: Math.random() * 0.03 + 0.02,
                floatOffset: Math.random() * Math.PI * 2
            });
        }

        // Enemies
        const enemies = [];
        let totalFriendlyNPCs = 0;

        // Health bar for enemies
        const healthBarOuterGeometry = new THREE.PlaneGeometry(1.2, 0.2);
        const healthBarOuterMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const healthBarFillGeometry = new THREE.PlaneGeometry(1.0, 0.15);
        const healthBarFillMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });

        function createEnemyHealthBar() {
            const healthBarGroup = new THREE.Group();

            const outerBar = new THREE.Mesh(healthBarOuterGeometry, healthBarOuterMaterial);
            healthBarGroup.add(outerBar);

            const fillBar = new THREE.Mesh(healthBarFillGeometry, healthBarFillMaterial);
            fillBar.position.x = -0.05;
            healthBarGroup.add(fillBar);

            healthBarGroup.position.y = 2.5;
            healthBarGroup.visible = false;
            return { group: healthBarGroup, fill: fillBar };
        }

        // Turtle Enemy
        function createTurtle(x, z) {
            const turtleGroup = new THREE.Group();

            // Shell
            const shellGeometry = new THREE.SphereGeometry(0.8, 24, 12, 0, Math.PI * 2, 0, Math.PI * 0.5);
            const shellMaterial = new THREE.MeshStandardMaterial({
                map: textureLoader.load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg'),
                roughness: 0.6,
                metalness: 0.1
            });
            const shell = new THREE.Mesh(shellGeometry, shellMaterial);
            shell.position.y = 0.5;
            shell.castShadow = true;
            turtleGroup.add(shell);

            // Head
            const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({ 
                color: '#90EE90',
                roughness: 0.5
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0, 0.3, 0.8);
            turtleGroup.add(head);

            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: '#000000' });
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.1, 0.35, 1.05);
            turtleGroup.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.1, 0.35, 1.05);
            turtleGroup.add(rightEye);

            // Mouth
            const mouthGeometry = new THREE.BoxGeometry(0.3, 0.1, 0.1);
            const mouthMaterial = new THREE.MeshStandardMaterial({ color: '#000000' });
            const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
            mouth.position.set(0, 0.25, 0.9);
            turtleGroup.add(mouth);

            // Teeth
            const toothGeometry = new THREE.BoxGeometry(0.05, 0.05, 0.05);
            const toothMaterial = new THREE.MeshStandardMaterial({ color: '#FFFFFF' });
            for (let i = 0; i < 4; i++) {
                const tooth = new THREE.Mesh(toothGeometry, toothMaterial);
                tooth.position.set(-0.12 + (i * 0.08), 0.25, 0.95);
                turtleGroup.add(tooth);
            }

            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.3, 8);
            const legMaterial = new THREE.MeshStandardMaterial({ color: '#90EE90' });
            
            const positions = [
                [-0.3, 0.1, 0.5], [0.3, 0.1, 0.5],  // Front legs
                [-0.3, 0.1, -0.3], [0.3, 0.1, -0.3]  // Back legs
            ];
            
            positions.forEach(pos => {
                const leg = new THREE.Mesh(legGeometry, legMaterial);
                leg.position.set(pos[0], pos[1], pos[2]);
                turtleGroup.add(leg);
            });

            turtleGroup.position.set(x, 0, z);
            scene.add(turtleGroup);
            
            // Patrol points for movement
            const patrolPoints = [
                new THREE.Vector3(x, 0, z),
                new THREE.Vector3(x + (Math.random() * 10 - 5), 0, z + (Math.random() * 10 - 5)),
                new THREE.Vector3(x + (Math.random() * 10 - 5), 0, z + (Math.random() * 10 - 5)),
                new THREE.Vector3(x + (Math.random() * 10 - 5), 0, z + (Math.random() * 10 - 5))
            ];

            const healthBar = createEnemyHealthBar();
            turtleGroup.add(healthBar.group);

            return {
                type: 'turtle',
                mesh: turtleGroup,
                health: 1,
                maxHealth: 1,
                speed: 0.02,
                patrolPoints: patrolPoints,
                currentPatrolIndex: 0,
                isChasing: false,
                detectionRange: 8,
                damage: 10,
                defeated: false,
                lastAttackTime: 0,
                attackCooldown: 1500,
                healthBar: healthBar
            };
        }

        // Goober Enemy
        function createGoober(x, z) {
            const gooberGroup = new THREE.Group();

            // Body
            const bodyGeometry = new THREE.SphereGeometry(0.7, 24, 24);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: '#8A2BE2',
                transparent: true,
                opacity: 0.9,
                roughness: 0.3,
                metalness: 0.2
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.7;
            body.castShadow = true;
            gooberGroup.add(body);

            // Eye
            const eyeGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            const eyeMaterial = new THREE.MeshStandardMaterial({ 
                color: '#FFFFFF',
                roughness: 0.1
            });
            const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            eye.position.set(0, 0.8, 0.6);
            gooberGroup.add(eye);

            const pupilGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const pupilMaterial = new THREE.MeshStandardMaterial({ color: '#000000' });
            const pupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            pupil.position.set(0, 0.8, 0.8);
            gooberGroup.add(pupil);

            // Mouth
            const mouthGeometry = new THREE.TorusGeometry(0.15, 0.03, 8, 12, Math.PI);
            const mouthMaterial = new THREE.MeshStandardMaterial({ color: '#FF0000' });
            const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
            mouth.position.set(0, 0.5, 0.7);
            mouth.rotation.x = Math.PI;
            gooberGroup.add(mouth);

            gooberGroup.position.set(x, 0, z);
            scene.add(gooberGroup);
            
            const healthBar = createEnemyHealthBar();
            gooberGroup.add(healthBar.group);

            return {
                type: 'goober',
                mesh: gooberGroup,
                health: 3,
                maxHealth: 3,
                speed: 0.04,
                initialPosition: new THREE.Vector3(x, 0, z),
                isChasing: false,
                detectionRange: 15,
                damage: 15,
                defeated: false,
                lastAttackTime: 0,
                attackCooldown: 1000,
                healthBar: healthBar
            };
        }

        // Bully Enemy
        function createBully(x, z) {
            const bullyGroup = new THREE.Group();

            // Body
            const bodyGeometry = new THREE.BoxGeometry(1, 2, 0.8);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: '#B22222',
                roughness: 0.6
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1;
            body.castShadow = true;
            bullyGroup.add(body);

            // Head
            const headGeometry = new THREE.SphereGeometry(0.5, 24, 24);
            const headMaterial = new THREE.MeshStandardMaterial({ 
                color: '#FFDAB9',
                roughness: 0.4
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 2.2;
            bullyGroup.add(head);

            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.06, 8, 8);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: '#000000' });
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.15, 2.25, 0.45);
            bullyGroup.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.15, 2.25, 0.45);
            bullyGroup.add(rightEye);

            // Eyebrows
            const eyebrowGeometry = new THREE.BoxGeometry(0.2, 0.05, 0.05);
            const eyebrowMaterial = new THREE.MeshStandardMaterial({ color: '#000000' });
            const leftEyebrow = new THREE.Mesh(eyebrowGeometry, eyebrowMaterial);
            leftEyebrow.position.set(-0.2, 2.35, 0.4);
            leftEyebrow.rotation.z = Math.PI / 6;
            bullyGroup.add(leftEyebrow);
            const rightEyebrow = new THREE.Mesh(eyebrowGeometry, eyebrowMaterial);
            rightEyebrow.position.set(0.2, 2.35, 0.4);
            rightEyebrow.rotation.z = -Math.PI / 6;
            bullyGroup.add(rightEyebrow);

            // Mouth
            const mouthGeometry = new THREE.BoxGeometry(0.4, 0.1, 0.1);
            const mouthMaterial = new THREE.MeshStandardMaterial({ color: '#000000' });
            const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
            mouth.position.set(0, 2.0, 0.45);
            bullyGroup.add(mouth);

            // Teeth
            const toothGeometry = new THREE.BoxGeometry(0.05, 0.05, 0.05);
            const toothMaterial = new THREE.MeshStandardMaterial({ color: '#FFFFFF' });
            for (let i = 0; i < 4; i++) {
                const tooth = new THREE.Mesh(toothGeometry, toothMaterial);
                tooth.position.set(-0.15 + (i * 0.1), 1.95, 0.5);
                bullyGroup.add(tooth);
            }

            // Hair
            const hairConeGeometry = new THREE.ConeGeometry(0.15, 0.4, 6);
            const hairMaterial = new THREE.MeshStandardMaterial({ 
                color: '#663399',
                roughness: 0.5
            });
            
            const hairPositions = [
                [-0.2, 2.6, 0.2], [0.2, 2.6, 0.2],
                [-0.3, 2.5, -0.1], [0.3, 2.5, -0.1],
                [0, 2.7, 0]
            ];
            
            hairPositions.forEach(pos => {
                const hair = new THREE.Mesh(hairConeGeometry, hairMaterial);
                hair.position.set(pos[0], pos[1], pos[2]);
                hair.rotation.z = (Math.random() - 0.5) * Math.PI / 4;
                bullyGroup.add(hair);
            });

            bullyGroup.position.set(x, 0, z);
            scene.add(bullyGroup);
            
            const healthBar = createEnemyHealthBar();
            bullyGroup.add(healthBar.group);

            return {
                type: 'bully',
                mesh: bullyGroup,
                health: 5,
                maxHealth: 5,
                speed: 0.05,
                initialPosition: new THREE.Vector3(x, 0, z),
                isChasing: false,
                detectionRange: 20,
                damage: 25,
                defeated: false,
                lastAttackTime: 0,
                attackCooldown: 2000,
                healthBar: healthBar
            };
        }

        // Friendly NPCs
        const friendlyNPCs = [];
        const npcDialogue = {
            "Willow": ["Hi, I'm Willow!", "Nice to meet you!", "The Sparkle Academy is that way!"],
            "Finn": ["I'm Finn, how are you?", "Watch out for the bullies!", "Collect gems to level up!"],
            "Luna": ["Luna here! Welcome!", "The turtles are slow but persistent.", "You can jump on enemies to hurt them!"]
        };

        function createFriendlyNPC(x, z, name) {
            const npcGroup = new THREE.Group();

            // Body
            const bodyGeometry = new THREE.CylinderGeometry(0.4, 0.4, 1.3, 16);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: '#C0C0C0',
                metalness: 0.3,
                roughness: 0.4
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.65;
            npcGroup.add(body);

            // Head
            const headGeometry = new THREE.SphereGeometry(0.4, 24, 24);
            const headMaterial = new THREE.MeshStandardMaterial({ 
                color: '#FFDAB9',
                roughness: 0.3
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.6;
            npcGroup.add(head);

            // Face features
            const eyeGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: '#000000' });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.1, 1.65, 0.35);
            npcGroup.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.1, 1.65, 0.35);
            npcGroup.add(rightEye);
            
            const mouthGeometry = new THREE.TorusGeometry(0.08, 0.02, 8, 12, Math.PI);
            const mouthMaterial = new THREE.MeshStandardMaterial({ color: '#FF6B6B' });
            const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
            mouth.position.set(0, 1.55, 0.35);
            mouth.rotation.x = Math.PI;
            npcGroup.add(mouth);

            // Random accessory
            const randAcc = Math.random();
            if (randAcc < 0.33) { // Hat
                const hatGeometry = new THREE.ConeGeometry(0.5, 0.7, 8);
                const hatMaterial = new THREE.MeshStandardMaterial({ 
                    color: '#00BFFF',
                    roughness: 0.5
                });
                const hat = new THREE.Mesh(hatGeometry, hatMaterial);
                hat.position.y = 2.2;
                npcGroup.add(hat);
                
                const hatBandGeometry = new THREE.TorusGeometry(0.5, 0.05, 8, 16);
                const hatBandMaterial = new THREE.MeshStandardMaterial({ color: '#FFD700' });
                const hatBand = new THREE.Mesh(hatBandGeometry, hatBandMaterial);
                hatBand.position.y = 1.9;
                hatBand.rotation.x = Math.PI / 2;
                npcGroup.add(hatBand);
            } else if (randAcc < 0.66) { // Bow
                const bowPart = new THREE.BoxGeometry(0.3, 0.1, 0.05);
                const bowMaterial = new THREE.MeshStandardMaterial({ color: '#FF69B4' });
                
                const bowLeft = new THREE.Mesh(bowPart, bowMaterial);
                bowLeft.position.set(-0.2, 1.8, 0.5);
                bowLeft.rotation.z = Math.PI / 4;
                
                const bowRight = new THREE.Mesh(bowPart, bowMaterial);
                bowRight.position.set(0.2, 1.8, 0.5);
                bowRight.rotation.z = -Math.PI / 4;
                
                const bowCenter = new THREE.Mesh(
                    new THREE.BoxGeometry(0.1, 0.1, 0.1),
                    bowMaterial
                );
                bowCenter.position.set(0, 1.8, 0.5);
                
                npcGroup.add(bowLeft);
                npcGroup.add(bowRight);
                npcGroup.add(bowCenter);
            } else { // Glasses
                const glassGeometry = new THREE.TorusGeometry(0.1, 0.02, 8, 16);
                const glassMaterial = new THREE.MeshStandardMaterial({ 
                    color: '#000000',
                    metalness: 0.5
                });
                
                const leftGlass = new THREE.Mesh(glassGeometry, glassMaterial);
                leftGlass.position.set(-0.1, 1.65, 0.4);
                leftGlass.rotation.y = Math.PI / 2;
                
                const rightGlass = new THREE.Mesh(glassGeometry, glassMaterial);
                rightGlass.position.set(0.1, 1.65, 0.4);
                rightGlass.rotation.y = Math.PI / 2;
                
                const bridge = new THREE.Mesh(
                    new THREE.BoxGeometry(0.15, 0.02, 0.02),
                    glassMaterial
                );
                bridge.position.set(0, 1.65, 0.4);
                
                npcGroup.add(leftGlass);
                npcGroup.add(rightGlass);
                npcGroup.add(bridge);
            }

            npcGroup.position.set(x, 0, z);
            scene.add(npcGroup);
            
            // Create patrol points for wandering
            const patrolPoints = [
                new THREE.Vector3(x, 0, z),
                new THREE.Vector3(x + (Math.random() * 10 - 5), 0, z + (Math.random() * 10 - 5)),
                new THREE.Vector3(x + (Math.random() * 10 - 5), 0, z + (Math.random() * 10 - 5)),
                new THREE.Vector3(x + (Math.random() * 10 - 5), 0, z + (Math.random() * 10 - 5))
            ];
            
            return {
                type: 'friendlyNPC',
                mesh: npcGroup,
                name: name,
                met: false,
                patrolPoints: patrolPoints,
                currentPatrolIndex: 0,
                lastInteractionTime: 0,
                interactionCooldown: 3000,
                lastMoveTime: 0,
                moveCooldown: 2000,
                speed: 0.01
            };
        }

        // Projectiles
        const projectiles = [];
        const projectileGeometry = new THREE.SphereGeometry(0.2, 16, 16);
        const projectileMaterial = new THREE.MeshStandardMaterial({
            color: '#FF69B4',
            emissive: '#FFD700',
            emissiveIntensity: 0.7,
            transparent: true,
            opacity: 0.9
        });

        // Stone Projectiles (for bullies)
        const stoneProjectiles = [];
        const stoneGeometry = new THREE.SphereGeometry(0.3, 8, 8);
        const stoneMaterial = new THREE.MeshStandardMaterial({
            color: '#808080',
            roughness: 0.8,
            metalness: 0.2
        });

        function fireStoneProjectile(enemy) {
            const now = Date.now();
            if (now - enemy.lastAttackTime < enemy.attackCooldown) return;
            enemy.lastAttackTime = now;

            const stone = new THREE.Mesh(stoneGeometry, stoneMaterial);
            stone.position.copy(enemy.mesh.position);
            stone.position.y += 1.5;
            
            const direction = new THREE.Vector3().subVectors(
                playerGroup.position, enemy.mesh.position
            ).normalize();
            
            scene.add(stone);
            stoneProjectiles.push({
                mesh: stone,
                direction: direction,
                speed: 0.15,
                distance: 0,
                maxDistance: 30,
                damage: 10
            });
        }

        // Game State
        const gameState = {
            score: 0,
            health: 100,
            maxHealth: 100,
            gameOver: false,
            level: 1,
            objectives: [
                "Collect 5 magical gems",
                "Defeat 1 Turtle",
                "Defeat 1 Goober",
                "Defeat 1 Bully",
                "Meet all friendly NPCs",
                "Find the Sparkle Academy",
                "Collect all sparkle globes"
            ],
            inventory: [],
            collectedGems: 0,
            defeatedEnemyTypes: {
                turtle: false,
                goober: false,
                bully: false
            },
            metNPCs: new Set(),
            collectedGlobes: 0,
            lastDamageTime: 0,
            invincibilityDuration: 1000,
            inInterior: false,
            currentInterior: null,
            memoryGame: {
                cards: ['üéí', '‚úèÔ∏è', ' üí∞', 'üñçÔ∏è', ' üê¢', '‚ú®', 'üìì', ' üè∞'],
                flippedCards: [],
                matchedPairs: 0,
                totalPairs: 4
            },
            shapeGame: {
                targetShape: '',
                score: 0,
                gameActive: false
            },
            allQuestsCompleted: false
        };

        // Player Physics
        const playerPhysics = {
            velocity: new THREE.Vector3(),
            direction: new THREE.Vector3(),
            moveSpeed: 0.2,
            jumpForce: 0.25,
            gravity: -0.01,
            isGrounded: false,
            canJump: true,
            isJumping: false
        };

        // Camera Controls
        let cameraDistance = 10;
        let cameraAngle = Math.PI / 4;
        let cameraHeight = 5;

        // Controls
        const controls = {
            move: {
                active: false,
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0
            },
            camera: {
                active: false,
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0
            },
            jumpBtn: document.getElementById('jumpBtn'),
            attackBtn: document.getElementById('attackBtn'),
            lastAttackTime: 0,
            attackCooldown: 500,
            lockOnRange: 20
        };

        // Setup controls
        function setupControls() {
            const leftTouch = document.getElementById('left-touch');
            const rightTouch = document.getElementById('right-touch');
            
            // Left side - Movement
            leftTouch.addEventListener('touchstart', (e) => {
                controls.move.active = true;
                controls.move.startX = e.touches[0].clientX;
                controls.move.startY = e.touches[0].clientY;
                e.preventDefault();
            });
            
            leftTouch.addEventListener('mousedown', (e) => {
                controls.move.active = true;
                controls.move.startX = e.clientX;
                controls.move.startY = e.clientY;
                e.preventDefault();
            });
            
            // Right side - Camera
            rightTouch.addEventListener('touchstart', (e) => {
                controls.camera.active = true;
                controls.camera.startX = e.touches[0].clientX;
                controls.camera.startY = e.touches[0].clientY;
                e.preventDefault();
            });
            
            rightTouch.addEventListener('mousedown', (e) => {
                controls.camera.active = true;
                controls.camera.startX = e.clientX;
                controls.camera.startY = e.clientY;
                e.preventDefault();
            });
            
            // Movement
            document.addEventListener('touchmove', (e) => {
                if (e.touches && e.touches.length > 0) {
                    const touchMove = Array.from(e.touches).find(t => t.target === leftTouch || t.target === rightTouch);
                    if (touchMove) {
                        if (touchMove.target === leftTouch) {
                            controls.move.currentX = touchMove.clientX;
                            controls.move.currentY = touchMove.clientY;
                        } else if (touchMove.target === rightTouch) {
                            controls.camera.currentX = touchMove.clientX;
                            controls.camera.currentY = touchMove.clientY;
                        }
                    }
                } else { // Mouse
                    if (controls.move.active) {
                        controls.move.currentX = e.clientX;
                        controls.move.currentY = e.clientY;
                    }
                    if (controls.camera.active) {
                        controls.camera.currentX = e.clientX;
                        controls.camera.currentY = e.clientY;
                    }
                }
                e.preventDefault();
            }, { passive: false });

            // End events
            document.addEventListener('touchend', (e) => {
                if (e.changedTouches) {
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        const touch = e.changedTouches[i];
                        if (touch.target === leftTouch) controls.move.active = false;
                        if (touch.target === rightTouch) controls.camera.active = false;
                    }
                }
            });
            
            document.addEventListener('mouseup', () => {
                controls.move.active = false;
                controls.camera.active = false;
            });
            
            // Jump button
            controls.jumpBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (playerPhysics.isGrounded && playerPhysics.canJump) {
                    playerPhysics.velocity.y = playerPhysics.jumpForce;
                    playerPhysics.isGrounded = false;
                    playerPhysics.canJump = false;
                    playerPhysics.isJumping = true;
                    setTimeout(() => {
                        playerPhysics.canJump = true;
                    }, 500);
                }
            });
            
            controls.jumpBtn.addEventListener('mousedown', () => {
                if (playerPhysics.isGrounded && playerPhysics.canJump) {
                    playerPhysics.velocity.y = playerPhysics.jumpForce;
                    playerPhysics.isGrounded = false;
                    playerPhysics.canJump = false;
                    playerPhysics.isJumping = true;
                    setTimeout(() => {
                        playerPhysics.canJump = true;
                    }, 500);
                }
            });
            
            // Attack button
            controls.attackBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                fireProjectile();
            });
            
            controls.attackBtn.addEventListener('mousedown', () => {
                fireProjectile();
            });

            // Exit interior button
            document.getElementById('exitInterior').addEventListener('click', exitInterior);
            
            // Next level button
            document.getElementById('nextLevelBtn').addEventListener('click', () => {
                document.getElementById('victoryScreen').style.display = 'none';
                // Here you would typically load the next level
                alert("Next level would load here! This is the end of the demo.");
            });
        }

        function fireProjectile() {
            const now = Date.now();
            if (now - controls.lastAttackTime < controls.attackCooldown) return;
            controls.lastAttackTime = now;

            const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
            projectile.position.copy(playerGroup.position);
            projectile.position.y += 1.5;
            
            let direction = new THREE.Vector3();
            let targetEnemy = null;
            let closestDistance = Infinity;

            // Find closest enemy for auto-lock
            for (const enemy of enemies) {
                if (enemy.health <= 0) continue;
                const distance = playerGroup.position.distanceTo(enemy.mesh.position);
                if (distance < closestDistance && distance < controls.lockOnRange) {
                    closestDistance = distance;
                    targetEnemy = enemy;
                }
            }

            if (targetEnemy) {
                direction.subVectors(targetEnemy.mesh.position, projectile.position).normalize();
            } else {
                const forwardVector = new THREE.Vector3(0, 0, -1)
                    .applyQuaternion(playerGroup.quaternion);
                direction.copy(forwardVector);
            }
            
            scene.add(projectile);
            projectiles.push({
                mesh: projectile,
                direction: direction,
                speed: 0.3,
                distance: 0,
                maxDistance: 30
            });

            createEmotionBubble(playerGroup.position, "üí•", 1000);
            
            const sparkle = document.createElement('div');
            sparkle.className = 'sparkle-effect';
            const playerScreenPos = new THREE.Vector3();
            playerGroup.updateWorldMatrix(true, false);
            playerGroup.getWorldPosition(playerScreenPos);
            playerScreenPos.project(camera);

            const x = (playerScreenPos.x * .5 + .5) * canvas.clientWidth;
            const y = (-playerScreenPos.y * .5 + .5) * canvas.clientHeight;

            sparkle.style.left = `${x - 10}px`;
            sparkle.style.top = `${y - 10}px`;
            document.getElementById('ui').appendChild(sparkle);
            
            setTimeout(() => {
                sparkle.remove();
            }, 500);
        }

        // Memory Match Game
        function setupMemoryGame() {
            const memoryGame = document.getElementById('memoryGame');
            memoryGame.innerHTML = '';
            gameState.memoryGame.flippedCards = [];
            gameState.memoryGame.matchedPairs = 0;
            
            // Create pairs of cards
            const cards = [...gameState.memoryGame.cards.slice(0, gameState.memoryGame.totalPairs), 
                          ...gameState.memoryGame.cards.slice(0, gameState.memoryGame.totalPairs)];
            
            // Shuffle cards
            for (let i = cards.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [cards[i], cards[j]] = [cards[j], cards[i]];
            }
            
            // Create card elements
            cards.forEach((card, index) => {
                const cardElement = document.createElement('div');
                cardElement.className = 'memory-card';
                cardElement.dataset.index = index;
                cardElement.dataset.value = card;
                cardElement.textContent = '?';
                
                cardElement.addEventListener('click', () => flipCard(cardElement));
                memoryGame.appendChild(cardElement);
            });
            
            document.getElementById('miniGameMessage').textContent = 'Find all matching pairs!';
        }

        function flipCard(cardElement) {
            // Don't flip if already flipped or matched
            if (cardElement.classList.contains('flipped') || 
                gameState.memoryGame.flippedCards.length >= 2) {
                return;
            }
            
            cardElement.classList.add('flipped');
            cardElement.textContent = cardElement.dataset.value;
            gameState.memoryGame.flippedCards.push(cardElement);
            
            if (gameState.memoryGame.flippedCards.length === 2) {
                checkForMatch();
            }
        }

        function checkForMatch() {
            const [card1, card2] = gameState.memoryGame.flippedCards;
            
            if (card1.dataset.value === card2.dataset.value) {
                // Match found
                gameState.memoryGame.matchedPairs++;
                gameState.memoryGame.flippedCards = [];
                
                if (gameState.memoryGame.matchedPairs === gameState.memoryGame.totalPairs) {
                    // Game won
                    document.getElementById('miniGameMessage').textContent = 'You won! Here are your rewards!';
                    gameState.score += 200;
                    updateScore();
                    
                    // Add gems near the player
                    for (let i = 0; i < 3; i++) {
                        const gem = new THREE.Mesh(gemGeometry, gemMaterial);
                        gem.position.copy(playerGroup.position);
                        gem.position.x += (Math.random() - 0.5) * 2;
                        gem.position.z += (Math.random() - 0.5) * 2;
                        scene.add(gem);
                        gems.push({
                            mesh: gem,
                            collected: false,
                            rotationSpeed: Math.random() * 0.02 + 0.01
                        });
                    }
                    
                    setTimeout(setupMemoryGame, 3000);
                }
            } else {
                // No match
                setTimeout(() => {
                    card1.classList.remove('flipped');
                    card2.classList.remove('flipped');
                    card1.textContent = '?';
                    card2.textContent = '?';
                    gameState.memoryGame.flippedCards = [];
                }, 1000);
            }
        }

        // Shape Matching Game
        function setupShapeGame() {
            document.getElementById('memoryGame').style.display = 'none';
            document.getElementById('shapeGame').style.display = 'flex';
            
            const shapes = ['üî∫', 'üîµ', '‚≠ê', '‚ù§Ô∏è', 'üî∂', 'üî∑'];
            gameState.shapeGame.targetShape = shapes[Math.floor(Math.random() * shapes.length)];
            document.getElementById('shapeTarget').textContent = gameState.shapeGame.targetShape;
            document.getElementById('shapeMessage').textContent = 'Match the shape above!';
            gameState.shapeGame.gameActive = true;
            
            // Setup shape click handlers
            document.querySelectorAll('.shape-option').forEach(option => {
                option.addEventListener('click', () => {
                    if (!gameState.shapeGame.gameActive) return;
                    
                    if (option.dataset.shape === gameState.shapeGame.targetShape) {
                        // Correct match
                        gameState.shapeGame.score++;
                        document.getElementById('shapeMessage').textContent = 'Correct! +50 points';
                        gameState.score += 50;
                        updateScore();
                        
                        // Change target shape
                        setTimeout(() => {
                            const remainingShapes = shapes.filter(s => s !== gameState.shapeGame.targetShape);
                            gameState.shapeGame.targetShape = remainingShapes[Math.floor(Math.random() * remainingShapes.length)];
                            document.getElementById('shapeTarget').textContent = gameState.shapeGame.targetShape;
                            document.getElementById('shapeMessage').textContent = 'Match the shape above!';
                        }, 1000);
                    } else {
                        // Wrong match
                        document.getElementById('shapeMessage').textContent = 'Try again!';
                    }
                });
            });
        }

        // Improved collision detection
        function checkCollisions() {
            playerCollider.setFromObject(playerGroup);
            
            // Ground collision
            playerPhysics.isGrounded = false;
            if (playerGroup.position.y <= 1) {
                playerGroup.position.y = 1;
                playerPhysics.velocity.y = 0;
                playerPhysics.isGrounded = true;
                playerPhysics.isJumping = false;
            }
            
            // Platform collisions
            for (const platform of platforms) {
                const platformBox = new THREE.Box3().setFromObject(platform.platform);
                const playerBoundingBox = playerCollider.clone();
                
                // Check if player is above the platform
                if (playerGroup.position.y > platform.height + 0.5) {
                    playerBoundingBox.min.y = playerGroup.position.y - 0.1;
                    playerBoundingBox.max.y = playerGroup.position.y;
                    
                    if (playerBoundingBox.intersectsBox(platformBox)) {
                        playerGroup.position.y = platform.height + 0.5;
                        playerPhysics.velocity.y = 0;
                        playerPhysics.isGrounded = true;
                        playerPhysics.isJumping = false;
                        
                        // Check for platform reward
                        if (platform.hasReward && !platform.rewardCollected) {
                            platform.rewardCollected = true;
                            createEmotionBubble(playerGroup.position, "üéÅ", 1500);
                            
                            // Add reward
                            gameState.score += 50;
                            updateScore();
                            
                            // Show visual reward effect
                            const reward = document.getElementById('platformReward');
                            const screenPos = new THREE.Vector3();
                            platform.platform.updateWorldMatrix(true, false);
                            platform.platform.getWorldPosition(screenPos);
                            screenPos.project(camera);
                            
                            const x = (screenPos.x * .5 + .5) * canvas.clientWidth;
                            const y = (-screenPos.y * .5 + .5) * canvas.clientHeight;
                            
                            reward.style.left = `${x - 10}px`;
                            reward.style.top = `${y - 10}px`;
                            reward.style.display = 'block';
                            
                            setTimeout(() => {
                                reward.style.display = 'none';
                            }, 1000);
                        }
                    }
                }
            }
            
            // Building/environment collisions - Improved algorithm
            // The fix here is to first apply the player movement, then check for collision
            // and correct the position. This prevents the player from getting "stuck"
            // in the collision box by constantly trying to enter it.
            // Also, we now use `playerGroup.position` directly and subtract the `velocity`
            // to get the previous position, which is more accurate.
            const previousPosition = playerGroup.position.clone();
            
            // Check for building/environment collisions
            for (const object of collidableObjects) {
                const objectBox = new THREE.Box3().setFromObject(object);
                const playerBox = playerCollider.clone();
                
                if (playerBox.intersectsBox(objectBox)) {
                    const overlapX = Math.min(
                        playerBox.max.x - objectBox.min.x,
                        objectBox.max.x - playerBox.min.x
                    );
                    
                    const overlapZ = Math.min(
                        playerBox.max.z - objectBox.min.z,
                        objectBox.max.z - playerBox.min.z
                    );
                    
                    // Push player back along the axis with the smallest overlap
                    if (overlapX < overlapZ) {
                        playerGroup.position.x = previousPosition.x;
                        playerPhysics.velocity.x = 0; // Stop movement in that direction
                    } else {
                        playerGroup.position.z = previousPosition.z;
                        playerPhysics.velocity.z = 0; // Stop movement in that direction
                    }
                }
            }
            
            // Check for house door interactions
            // This logic is now inside `checkCollisions` so it runs continuously.
            // A cooldown has been added to prevent re-entry immediately after exiting.
            const now = Date.now();
            if (!gameState.inInterior && (now - lastInteriorInteractionTime > interiorCooldown)) {
                for (const interior of houseInteriors) {
                    const doorDistance = playerGroup.position.distanceTo(interior.doorPosition);
                    if (doorDistance < 2) {
                        const playerDirection = new THREE.Vector3(0, 0, -1)
                            .applyQuaternion(playerGroup.quaternion);
                        const toDoorDirection = new THREE.Vector3()
                            .subVectors(interior.doorPosition, playerGroup.position)
                            .normalize();
                        
                        const dot = playerDirection.dot(toDoorDirection);
                        if (dot > 0.7 && controls.move.active) {
                            enterInterior(interior);
                        }
                    }
                }
            }
            
            // Check for castle door interaction
            const castleDoorPos = new THREE.Vector3(0, 1, -62.4);
            const castleDoorDistance = playerGroup.position.distanceTo(castleDoorPos);
            if (castleDoorDistance < 3 && gameState.allQuestsCompleted) {
                showVictoryScreen();
            }
            
            // Gem collection
            for (const gem of gems) {
                if (gem.collected) continue;
                
                const gemPos = gem.mesh.position;
                const distance = playerGroup.position.distanceTo(gemPos);
                
                if (distance < 1.5) {
                    gem.collected = true;
                    scene.remove(gem.mesh);
                    gameState.score += 50;
                    gameState.collectedGems++;
                    updateScore();
                    
                    createEmotionBubble(playerGroup.position, "‚ú®", 1000);
                    
                    if (gameState.collectedGems === 5) {
                        completeObjective("Collect 5 magical gems");
                    }
                }
            }
            
            // Sparkle globe collection
            for (const globe of sparkleGlobes) {
                if (globe.collected) continue;
                
                const globePos = globe.mesh.position;
                const distance = playerGroup.position.distanceTo(globePos);
                
                if (distance < 2) {
                    globe.collected = true;
                    scene.remove(globe.mesh);
                    gameState.score += 200;
                    gameState.collectedGlobes++;
                    updateScore();
                    
                    createEmotionBubble(playerGroup.position, "üåü", 1500);
                    
                    if (gameState.collectedGlobes === sparkleGlobes.length) {
                        completeObjective("Collect all sparkle globes");
                        // Unlock shape game when all globes collected
                        setupShapeGame();
                    }
                }
            }
            
            // Academy discovery
            const academyDistance = playerGroup.position.distanceTo(academyGroup.position);
            if (academyDistance < 15 && !isObjectiveCompleted("Find the Sparkle Academy")) {
                completeObjective("Find the Sparkle Academy");
            }

            // Friendly NPC interaction
            for (const npc of friendlyNPCs) {
                const npcPos = npc.mesh.position;
                const distance = playerGroup.position.distanceTo(npcPos);
                const now = Date.now();

                if (distance < 3 && (now - npc.lastInteractionTime > npc.interactionCooldown)) {
                    if (!npc.met) {
                        npc.met = true;
                        gameState.metNPCs.add(npc.name);
                        if (gameState.metNPCs.size === totalFriendlyNPCs) {
                            completeObjective("Meet all friendly NPCs");
                        }
                    }
                    
                    showDialogue(npc.name);
                    npc.lastInteractionTime = now;
                }
            }
            
            // Projectile collisions with ENEMIES
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const projectile = projectiles[i];
                
                projectile.distance += projectile.speed;
                if (projectile.distance >= projectile.maxDistance) {
                    scene.remove(projectile.mesh);
                    projectiles.splice(i, 1);
                    continue;
                }
                
                projectile.mesh.position.add(
                    projectile.direction.clone().multiplyScalar(projectile.speed)
                );
                
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    if (enemy.health <= 0) continue;
                    
                    const enemyPos = enemy.mesh.position;
                    const distance = projectile.mesh.position.distanceTo(enemyPos);
                    
                    if (distance < 1) {
                        enemy.health--;
                        createEmotionBubble(enemyPos, "üí¢", 800);
                        updateEnemyHealthBar(enemy);

                        scene.remove(projectile.mesh);
                        projectiles.splice(i, 1);
                        
                        if (enemy.health <= 0) {
                            gameState.score += 100;
                            updateScore();
                            
                            gameState.defeatedEnemyTypes[enemy.type] = true;
                            completeObjective(`Defeat 1 ${enemy.type.charAt(0).toUpperCase() + enemy.type.slice(1)}`);
                            
                            scene.remove(enemy.healthBar.group);
                            setTimeout(() => {
                                scene.remove(enemy.mesh);
                            }, 500);
                            
                            for(let k=0; k < (enemy.type === 'bully' ? 5 : 2); k++) {
                                const newGem = new THREE.Mesh(gemGeometry, gemMaterial);
                                newGem.position.set(enemyPos.x + (Math.random()-0.5)*1, enemyPos.y + 0.5, enemyPos.z + (Math.random()-0.5)*1);
                                scene.add(newGem);
                                gems.push({mesh: newGem, collected: false, rotationSpeed: Math.random() * 0.05 + 0.02});
                            }
                        }
                        break;
                    }
                }
            }
            
            // Stone projectile collisions with PLAYER
            for (let i = stoneProjectiles.length - 1; i >= 0; i--) {
                const stone = stoneProjectiles[i];
                
                stone.distance += stone.speed;
                if (stone.distance >= stone.maxDistance) {
                    scene.remove(stone.mesh);
                    stoneProjectiles.splice(i, 1);
                    continue;
                }
                
                stone.mesh.position.add(
                    stone.direction.clone().multiplyScalar(stone.speed)
                );
                
                const distance = playerGroup.position.distanceTo(stone.mesh.position);
                if (distance < 1.5) {
                    const now = Date.now();
                    if (now - gameState.lastDamageTime > gameState.invincibilityDuration) {
                        takeDamage(stone.damage);
                        createEmotionBubble(playerGroup.position, "üíî", 800);
                        
                        const knockbackDirection = new THREE.Vector3().subVectors(
                            playerGroup.position, stone.mesh.position
                        ).normalize();
                        
                        playerPhysics.velocity.x = knockbackDirection.x * 0.2;
                        playerPhysics.velocity.z = knockbackDirection.z * 0.2;
                        playerPhysics.velocity.y = 0.1;
                    }
                    
                    scene.remove(stone.mesh);
                    stoneProjectiles.splice(i, 1);
                }
            }
            
            // Enemy collisions with player
            for (const enemy of enemies) {
                if (enemy.health <= 0) continue;
                
                const enemyPos = enemy.mesh.position;
                const distance = playerGroup.position.distanceTo(enemyPos);
                
                if (distance < 1.0) {
                    if (playerPhysics.isJumping && playerPhysics.velocity.y < 0) {
                        // Jump attack
                        enemy.health--;
                        createEmotionBubble(enemyPos, "üí•", 800);
                        updateEnemyHealthBar(enemy);
                        
                        playerPhysics.velocity.y = playerPhysics.jumpForce * 0.7;
                        playerPhysics.isJumping = true;

                        if (enemy.health <= 0) {
                            gameState.score += 100;
                            updateScore();
                            gameState.defeatedEnemyTypes[enemy.type] = true;
                            completeObjective(`Defeat 1 ${enemy.type.charAt(0).toUpperCase() + enemy.type.slice(1)}`);
                            scene.remove(enemy.healthBar.group);
                            setTimeout(() => {
                                scene.remove(enemy.mesh);
                            }, 500);
                            for(let k=0; k < (enemy.type === 'bully' ? 5 : 2); k++) {
                                const newGem = new THREE.Mesh(gemGeometry, gemMaterial);
                                newGem.position.set(enemyPos.x + (Math.random()-0.5)*1, enemyPos.y + 0.5, enemyPos.z + (Math.random()-0.5)*1);
                                scene.add(newGem);
                                gems.push({mesh: newGem, collected: false, rotationSpeed: Math.random() * 0.05 + 0.02});
                            }
                        }
                    } else {
                        const now = Date.now();
                        if (now - gameState.lastDamageTime > gameState.invincibilityDuration) {
                            takeDamage(enemy.damage);
                            createEmotionBubble(playerGroup.position, "üíî", 800);
                            
                            const knockbackDirection = new THREE.Vector3().subVectors(
                                playerGroup.position, enemyPos
                            ).normalize();
                            
                            playerPhysics.velocity.x = knockbackDirection.x * 0.2;
                            playerPhysics.velocity.z = knockbackDirection.z * 0.2;
                            playerPhysics.velocity.y = 0.1;
                        }
                    }
                }
            }
        }

        function enterInterior(interior) {
            gameState.inInterior = true;
            gameState.currentInterior = interior;
            lastInteriorInteractionTime = Date.now(); // Set the cooldown timer
            
            // Hide exterior
            interior.exterior.visible = false;
            
            // Show interior
            interior.interior.visible = true;
            
            // Position player inside
            playerGroup.position.copy(interior.position);
            playerGroup.position.z += 1.5;
            
            // Show interior UI and setup mini-game
            document.getElementById('interiorView').style.display = 'block';
            
            // Check if shape game should be shown (after completing globes objective)
            if (isObjectiveCompleted("Collect all sparkle globes")) {
                setupShapeGame();
            } else {
                setupMemoryGame();
            }
        }

        function exitInterior() {
            if (!gameState.inInterior) return;
            
            // Hide interior
            gameState.currentInterior.interior.visible = false;
            
            // Show exterior
            gameState.currentInterior.exterior.visible = true;
            
            // Position player outside, offset from the door to prevent immediate re-entry
            // The fix here is to set a new position that is far enough away from the door trigger
            // This prevents the `checkCollisions` function from immediately re-triggering `enterInterior`.
            const exitPosition = gameState.currentInterior.position.clone();
            exitPosition.z += 4.5;
            playerGroup.position.copy(exitPosition);
            
            // Hide interior UI
            document.getElementById('interiorView').style.display = 'none';
            document.getElementById('miniGameMessage').textContent = '';
            document.getElementById('shapeMessage').textContent = '';
            document.getElementById('memoryGame').style.display = 'grid';
            document.getElementById('shapeGame').style.display = 'none';
            
            gameState.inInterior = false;
            gameState.currentInterior = null;
            
            lastInteriorInteractionTime = Date.now(); // Reset cooldown on exit
        }

        function showDialogue(npcName) {
            const dialogueBox = document.getElementById('dialogueBox');
            const dialogues = npcDialogue[npcName];
            const randomDialogue = dialogues[Math.floor(Math.random() * dialogues.length)];
            
            dialogueBox.textContent = `${npcName}: ${randomDialogue}`;
            dialogueBox.style.display = 'block';
            
            setTimeout(() => {
                dialogueBox.style.display = 'none';
            }, 3000);
        }

        function showVictoryScreen() {
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('victoryScreen').style.display = 'block';
        }

        function takeDamage(amount) {
            if (gameState.gameOver) return;
            
            gameState.health = Math.max(0, gameState.health - amount);
            updateHealthBar();
            
            if (gameState.health <= 0) {
                gameOver();
            }
            gameState.lastDamageTime = Date.now();
        }

        function gameOver() {
            gameState.gameOver = true;
            document.getElementById('gameOver').style.display = 'block';
        }

        function restartGame() {
            gameState.health = gameState.maxHealth;
            gameState.score = 0;
            gameState.gameOver = false;
            gameState.level = 1;
            gameState.collectedGems = 0;
            gameState.collectedGlobes = 0;
            gameState.defeatedEnemyTypes = { turtle: false, goober: false, bully: false };
            gameState.metNPCs.clear();
            gameState.lastDamageTime = 0;
            gameState.inInterior = false;
            gameState.currentInterior = null;
            gameState.shapeGame.gameActive = false;
            gameState.shapeGame.score = 0;
            gameState.allQuestsCompleted = false;

            playerGroup.position.set(0, 1, 0);
            playerPhysics.velocity.set(0, 0, 0);
            playerPhysics.isGrounded = true;
            playerPhysics.isJumping = false;
            playerPhysics.canJump = true;
            
            // Clear existing game objects
            gems.forEach(gem => scene.remove(gem.mesh));
            gems.length = 0;
            sparkleGlobes.forEach(globe => scene.remove(globe.mesh));
            sparkleGlobes.length = 0;
            enemies.forEach(enemy => {
                if (enemy.healthBar && enemy.healthBar.group.parent) {
                    enemy.healthBar.group.parent.remove(enemy.healthBar.group);
                }
                scene.remove(enemy.mesh)
            });
            enemies.length = 0;
            friendlyNPCs.forEach(npc => scene.remove(npc.mesh));
            friendlyNPCs.length = 0;
            projectiles.forEach(p => scene.remove(p.mesh));
            projectiles.length = 0;
            stoneProjectiles.forEach(s => scene.remove(s.mesh));
            stoneProjectiles.length = 0;
            // The following loop is a bug, removing interiors is handled by their parent groups
            // houseInteriors.forEach(interior => scene.remove(interior.interior));
            houseInteriors.length = 0;
            platforms.forEach(platform => scene.remove(platform.mesh));
            platforms.length = 0;
            paths.forEach(path => scene.remove(path));
            paths.length = 0;
            collidableObjects.length = 0; // Clear collision objects
            buildings.length = 0; // Clear buildings

            document.getElementById('interiorView').style.display = 'none';
            document.getElementById('dialogueBox').style.display = 'none';
            document.getElementById('memoryGame').style.display = 'grid';
            document.getElementById('shapeGame').style.display = 'none';
            document.getElementById('victoryScreen').style.display = 'none';

            initGameContent();
            updateHealthBar();
            updateScore();
            updateObjectivesList();
            document.getElementById('gameOver').style.display = 'none';
        }

        document.getElementById('restartBtn').addEventListener('click', restartGame);

        function updateHealthBar() {
            const healthPercent = (gameState.health / gameState.maxHealth) * 100;
            document.getElementById('healthFill').style.width = `${healthPercent}%`;
        }

        function updateEnemyHealthBar(enemy) {
            const healthPercent = enemy.health / enemy.maxHealth;
            enemy.healthBar.fill.scale.x = healthPercent;
            enemy.healthBar.fill.position.x = -0.5 * (1 - healthPercent);

            if (enemy.health <= 0) {
                enemy.healthBar.group.visible = false;
            } else {
                enemy.healthBar.group.visible = true;
            }
        }

        function updateScore() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('totalScore').textContent = gameState.score;
            
            let completionValue = 0;
            completionValue += Math.min(gameState.collectedGems, 5) / 5 * 25;
            if (gameState.defeatedEnemyTypes.turtle) completionValue += (25 / 3);
            if (gameState.defeatedEnemyTypes.goober) completionValue += (25 / 3);
            if (gameState.defeatedEnemyTypes.bully) completionValue += (25 / 3);
            completionValue += (gameState.metNPCs.size / totalFriendlyNPCs) * 25;
            if (isObjectiveCompleted("Find the Sparkle Academy")) completionValue += 25;
            
            document.getElementById('completion').textContent = `${Math.round(completionValue)}%`;
            
            if (gameState.score >= gameState.level * 1000) {
                gameState.level++;
                document.getElementById('gameLevel').textContent = gameState.level;
                createEmotionBubble(playerGroup.position, "‚¨ÜÔ∏è", 1500);
                
                gameState.health = Math.min(gameState.maxHealth, gameState.health + 30);
                updateHealthBar();
            }
        }

        function isObjectiveCompleted(objectiveText) {
            return gameState.objectives.includes(`${objectiveText} (Completed)`);
        }

        function completeObjective(text) {
            const index = gameState.objectives.indexOf(text);
            const completedText = `${text} (Completed)`;

            if (index !== -1 && gameState.objectives[index] !== completedText) {
                if (text.startsWith("Defeat 1 ")) {
                    const enemyType = text.replace("Defeat 1 ", "").toLowerCase();
                    if (!gameState.defeatedEnemyTypes[enemyType]) return;
                } else if (text === "Meet all friendly NPCs") {
                    if (gameState.metNPCs.size < totalFriendlyNPCs) return;
                }
                
                gameState.objectives[index] = completedText;
                updateObjectivesList();
                
                if (text.includes("Collect") && !text.includes("Collect all sparkle globes")) {
                    const itemName = text.split(" (Completed)")[0];
                    if (!gameState.inventory.includes(itemName)) {
                        gameState.inventory.push(itemName);
                        
                        const inventoryList = document.getElementById('inventoryList');
                        inventoryList.innerHTML = '';
                        gameState.inventory.forEach(item => {
                            const li = document.createElement('li');
                            li.textContent = item;
                            inventoryList.appendChild(li);
                        });
                    }
                }
                
                createEmotionBubble(playerGroup.position, "‚úÖ", 1500);
                
                // Check if all quests are completed
                checkAllQuestsCompleted();
            }
        }

        function checkAllQuestsCompleted() {
            const allCompleted = gameState.objectives.every(obj => obj.includes("(Completed)"));
            if (allCompleted && !gameState.allQuestsCompleted) {
                gameState.allQuestsCompleted = true;
                createEmotionBubble(playerGroup.position, "üéâ", 2000);
                
                // Make the castle door sparkle
                const doorPos = new THREE.Vector3(0, 1, -62.4);
                createEmotionBubble(doorPos, "üö™", 3000);
                
                // Show message about the castle
                setTimeout(() => {
                    showDialogue("Quest Master", "Congratulations! You've completed all quests! Now go to the Sparkle Academy castle!");
                }, 2000);
            }
        }

        function updateObjectivesList() {
            const objectivesList = document.getElementById('objectivesList');
            objectivesList.innerHTML = '';
            gameState.objectives.forEach(obj => {
                const item = document.createElement('div');
                item.className = 'quest-item';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'quest-checkbox';
                checkbox.disabled = true;
                
                if (obj.includes("(Completed)")) {
                    checkbox.checked = true;
                    item.classList.add('completed');
                }
                
                const label = document.createElement('label');
                label.textContent = obj;
                
                item.appendChild(checkbox);
                item.appendChild(label);
                objectivesList.appendChild(item);
            });
        }

        function createEmotionBubble(position, emoji, duration) {
            const bubble = document.createElement('div');
            bubble.className = 'emotion-bubble';
            bubble.textContent = emoji;
            
            const screenPos = position.clone().project(camera);
            const x = (screenPos.x * .5 + .5) * canvas.clientWidth;
            const y = (-screenPos.y * .5 + .5) * canvas.clientHeight;

            bubble.style.left = `${x - 15}px`;
            bubble.style.top = `${y - 15}px`;
            
            document.getElementById('ui').appendChild(bubble);
            
            setTimeout(() => {
                bubble.style.opacity = '1';
                bubble.style.transform = `translate(-50%, -100%) translateY(-50px)`;
            }, 10);
            
            setTimeout(() => {
                bubble.style.opacity = '0';
                setTimeout(() => {
                    bubble.remove();
                }, 300);
            }, duration);
        }

        // Quest menu
        document.getElementById('questBtn').addEventListener('click', (e) => {
            e.stopPropagation();
            const questMenu = document.getElementById('questMenu');
            questMenu.style.display = questMenu.style.display === 'block' ? 'none' : 'block';
        });

        document.querySelectorAll('.quest-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.quest-tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.quest-content').forEach(c => c.classList.remove('active'));
                
                tab.classList.add('active');
                document.getElementById(`${tab.dataset.tab}Tab`).classList.add('active');
            });
        });

        document.getElementById('questMenu').addEventListener('click', (e) => {
            e.stopPropagation();
        });

        document.getElementById('ui').addEventListener('click', (e) => {
            const questMenu = document.getElementById('questMenu');
            if (e.target.closest('#questMenu') === null && questMenu.style.display === 'block') {
                questMenu.style.display = 'none';
            }
        });

        // Initialize village layout
        function initVillageLayout() {
            // Create academy
            academyGroup.position.set(0, 0, -70);
            
            // Create houses in a village pattern
            createHouse(-20, 20);  // House 1
            createHouse(20, 20);   // House 2
            createHouse(0, 40);     // House 3
            createHouse(-40, 0);    // House 4
            createHouse(40, 0);     // House 5
            createHouse(-20, 60);   // House 6
            createHouse(20, 60);    // House 7
            
            // Create paths between buildings
            createVillagePaths();
            
            // Create platforms (without stairs)
            createPlatform(15, 25, 5, true);
            createPlatform(-15, 25, 5, true);
            createPlatform(0, 45, 7, true);
        }

        // Initialize game content
        function initGameContent() {
            // Initialize village layout
            initVillageLayout();
            
            // Create gems
            for (let i = 0; i < 20; i++) {
                const gem = new THREE.Mesh(gemGeometry, gemMaterial);
                gem.position.set(
                    (Math.random() - 0.5) * 180,
                    1,
                    (Math.random() - 0.5) * 180
                );
                gem.castShadow = true;
                scene.add(gem);
                gems.push({
                    mesh: gem,
                    collected: false,
                    rotationSpeed: Math.random() * 0.02 + 0.01
                });
            }

            // Create sparkle globes
            for (let i = 0; i < 5; i++) {
                const globe = new THREE.Mesh(globeGeometry, globeMaterial);
                globe.position.set(
                    (Math.random() - 0.5) * 100,
                    2,
                    (Math.random() - 0.5) * 100
                );
                globe.castShadow = true;
                scene.add(globe);
                sparkleGlobes.push({
                    mesh: globe,
                    collected: false,
                    rotationSpeed: Math.random() * 0.03 + 0.02,
                    floatOffset: Math.random() * Math.PI * 2
                });
            }

            // Create enemies
            enemies.push(createTurtle((Math.random() - 0.5) * 80, (Math.random() - 0.5) * 80));
            enemies.push(createTurtle((Math.random() - 0.5) * 80, (Math.random() - 0.5) * 80));
            enemies.push(createTurtle((Math.random() - 0.5) * 80, (Math.random() - 0.5) * 80));
            enemies.push(createTurtle((Math.random() - 0.5) * 80, (Math.random() - 0.5) * 80));
            enemies.push(createGoober((Math.random() - 0.5) * 60, (Math.random() - 0.5) * 60));
            enemies.push(createGoober((Math.random() - 0.5) * 60, (Math.random() - 0.5) * 60));
            enemies.push(createBully((Math.random() - 0.5) * 40, (Math.random() - 0.5) * 40));

            // Create friendly NPCs
            friendlyNPCs.push(createFriendlyNPC(-30, 20, "Willow"));
            friendlyNPCs.push(createFriendlyNPC(40, -10, "Finn"));
            friendlyNPCs.push(createFriendlyNPC(-15, -40, "Luna"));
            totalFriendlyNPCs = friendlyNPCs.length;

            updateObjectivesList();
        }

        function updateNPCs(deltaTime) {
            const now = Date.now();
            for (const npc of friendlyNPCs) {
                if (now - npc.lastMoveTime > npc.moveCooldown) {
                    const targetPoint = npc.patrolPoints[npc.currentPatrolIndex];
                    const distToTarget = npc.mesh.position.distanceTo(targetPoint);

                    if (distToTarget < 1) {
                        npc.currentPatrolIndex = (npc.currentPatrolIndex + 1) % npc.patrolPoints.length;
                        npc.lastMoveTime = now;
                        npc.moveCooldown = 2000 + Math.random() * 3000; // Random delay between 2-5 seconds
                    }

                    const direction = new THREE.Vector3().subVectors(
                        npc.patrolPoints[npc.currentPatrolIndex], 
                        npc.mesh.position
                    ).normalize();
                    
                    npc.mesh.position.x += direction.x * npc.speed;
                    npc.mesh.position.z += direction.z * npc.speed;
                    
                    // Face the direction they're moving
                    if (direction.length() > 0) {
                        const targetAngle = Math.atan2(direction.x, direction.z);
                        npc.mesh.rotation.y = targetAngle;
                    }
                }
            }
        }

        function updateCollectibles(deltaTime) {
            // Rotate gems
            for (const gem of gems) {
                if (!gem.collected) {
                    gem.mesh.rotation.y += gem.rotationSpeed;
                    gem.mesh.position.y = 1 + Math.sin(Date.now() * 0.002) * 0.2;
                }
            }

            // Float and rotate sparkle globes
            for (const globe of sparkleGlobes) {
                if (!globe.collected) {
                    globe.mesh.rotation.y += globe.rotationSpeed;
                    globe.mesh.position.y = 2 + Math.sin(Date.now() * 0.001 + globe.floatOffset) * 0.5;
                }
            }
        }

        // Animation loop
        let lastTime = 0;
        function animate(currentTime) {
            if (!lastTime) lastTime = currentTime;
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            if (!gameState.gameOver) {
                // Player movement
                if (controls.move.active && !gameState.inInterior) {
                    const deltaX = controls.move.currentX - controls.move.startX;
                    const deltaY = controls.move.currentY - controls.move.startY;
                    
                    const length = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    if (length > 10) {
                        const moveX = deltaX / length;
                        const moveZ = -deltaY / length;
                        
                        const cameraForward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                        const cameraRight = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                        
                        const moveDirection = new THREE.Vector3()
                            .addScaledVector(cameraForward, moveZ)
                            .addScaledVector(cameraRight, moveX)
                            .normalize();
                        
                        if (moveDirection.length() > 0) {
                            const targetAngle = Math.atan2(moveDirection.x, moveDirection.z);
                            playerGroup.rotation.y = targetAngle;
                        }
                        
                        playerGroup.position.x += moveDirection.x * playerPhysics.moveSpeed;
                        playerGroup.position.z += moveDirection.z * playerPhysics.moveSpeed;
                    }
                }
                
                // Camera control
                if (controls.camera.active && !gameState.inInterior) {
                    const deltaX = controls.camera.currentX - controls.camera.startX;
                    const deltaY = controls.camera.currentY - controls.camera.startY;
                    
                    if (Math.abs(deltaX) > 10 || Math.abs(deltaY) > 10) {
                        cameraAngle += deltaX * 0.001;
                        cameraDistance = Math.max(5, Math.min(15, cameraDistance - deltaY * 0.01));
                    }
                }
                
                // Apply gravity
                playerPhysics.velocity.y += playerPhysics.gravity;
                playerGroup.position.y += playerPhysics.velocity.y;
                
                // Update camera position
                if (!gameState.inInterior) {
                    camera.position.x = playerGroup.position.x + Math.sin(cameraAngle) * cameraDistance;
                    camera.position.z = playerGroup.position.z + Math.cos(cameraAngle) * cameraDistance;
                    camera.position.y = playerGroup.position.y + cameraHeight;
                    camera.lookAt(playerGroup.position);
                } else {
                    // Camera for interior view
                    camera.position.copy(playerGroup.position);
                    camera.position.y += 2;
                    camera.position.z += 2;
                    camera.lookAt(playerGroup.position);
                }
                
                checkCollisions();
                updateEnemies(deltaTime);
                updateNPCs(deltaTime);
                updateCollectibles(deltaTime);
            }
            
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        function updateEnemies(deltaTime) {
            for (const enemy of enemies) {
                if (enemy.health <= 0) {
                    enemy.healthBar.group.visible = false;
                    continue;
                }
                
                const distanceToPlayer = playerGroup.position.distanceTo(enemy.mesh.position);
                enemy.isChasing = distanceToPlayer < enemy.detectionRange;
                
                if (enemy.type === 'turtle') {
                    const targetPoint = enemy.patrolPoints[enemy.currentPatrolIndex];
                    const distToTarget = enemy.mesh.position.distanceTo(targetPoint);

                    if (distToTarget < 1) {
                        enemy.currentPatrolIndex = (enemy.currentPatrolIndex + 1) % enemy.patrolPoints.length;
                    }

                    const direction = new THREE.Vector3().subVectors(
                        enemy.patrolPoints[enemy.currentPatrolIndex], enemy.mesh.position
                    ).normalize();
                    
                    enemy.mesh.position.x += direction.x * enemy.speed;
                    enemy.mesh.position.z += direction.z * enemy.speed;
                    enemy.mesh.lookAt(enemy.mesh.position.clone().add(direction));
                } else if (enemy.type === 'goober') {
                    if (enemy.isChasing) {
                        const direction = new THREE.Vector3().subVectors(
                            playerGroup.position, enemy.mesh.position
                        ).normalize();
                        
                        enemy.mesh.position.x += direction.x * enemy.speed;
                        enemy.mesh.position.z += direction.z * enemy.speed;
                        
                        enemy.mesh.lookAt(playerGroup.position);
                    } else {
                        const returnDirection = new THREE.Vector3().subVectors(enemy.initialPosition, enemy.mesh.position);
                        if (returnDirection.length() > 0.1) {
                            returnDirection.normalize();
                            enemy.mesh.position.x += returnDirection.x * enemy.speed * 0.5;
                            enemy.mesh.position.z += returnDirection.z * enemy.speed * 0.5;
                        }
                    }
                } else if (enemy.type === 'bully') {
                    if (enemy.isChasing) {
                        // Keep distance from player
                        const direction = new THREE.Vector3().subVectors(
                            playerGroup.position, enemy.mesh.position
                        ).normalize();
                        
                        const desiredDistance = 5;
                        const currentDistance = playerGroup.position.distanceTo(enemy.mesh.position);
                        
                        if (currentDistance > desiredDistance) {
                            enemy.mesh.position.x += direction.x * enemy.speed;
                            enemy.mesh.position.z += direction.z * enemy.speed;
                        } else if (currentDistance < desiredDistance - 1) {
                            enemy.mesh.position.x -= direction.x * enemy.speed;
                            enemy.mesh.position.z -= direction.z * enemy.speed;
                        }
                        
                        enemy.mesh.lookAt(playerGroup.position);
                        
                        // Shoot projectiles at player
                        fireStoneProjectile(enemy);
                    } else {
                        const returnDirection = new THREE.Vector3().subVectors(enemy.initialPosition, enemy.mesh.position);
                        if (returnDirection.length() > 0.1) {
                            returnDirection.normalize();
                            enemy.mesh.position.x += returnDirection.x * enemy.speed * 0.5;
                            enemy.mesh.position.z += returnDirection.z * enemy.speed * 0.5;
                        }
                    }
                }
                enemy.healthBar.group.lookAt(camera.position);
            }
        }

        // Start the game
        setupControls();
        initGameContent();
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
